import sys
import io
import os
import struct
import binascii


MIN_METADATA_SIZE = 0xB2

AES_IV_POS = 0x14
AES_IV_SIZE = 16
PADDING_SIZE_POS = 0x24
ENC_KEY_DATA_POS = 0x28
RSA_KEY_SIZE = 128
METADATA_SIZE_POS = 0xA8
ATTACKER_ID_POS = 0xAC
ATTACKER_ID_SIZE = 6


def print_encfile_info(filename: str) -> bool:
    """Get encrypted file info"""

    with io.open(filename, 'rb') as f:

        # Read metadata
        f.seek(0, 2)
        file_size = f.tell()
        if file_size < MIN_METADATA_SIZE:
            return False

        f.seek(-MIN_METADATA_SIZE, 2)
        metadata = f.read(MIN_METADATA_SIZE)

        # Metadata size
        metadata_size, = struct.unpack_from('<L', metadata,
                                            METADATA_SIZE_POS)
        if metadata_size <= MIN_METADATA_SIZE:
            return False

        enc_filepath_size = metadata_size - MIN_METADATA_SIZE
        if (enc_filepath_size & 0xF) != 0:
            return False

        f.seek(-enc_filepath_size, 2)
        enc_filepath = f.read(enc_filepath_size)

    # AES IV
    aes_iv = metadata[AES_IV_POS : AES_IV_POS + AES_IV_SIZE]
    # Padding size
    padding_size, = struct.unpack_from('<L', metadata, PADDING_SIZE_POS)
    # Encrypted key data
    enc_key_data = metadata[ENC_KEY_DATA_POS :
                            ENC_KEY_DATA_POS + RSA_KEY_SIZE]
    # Attacker ID
    attacker_id = metadata[ATTACKER_ID_POS :
                           ATTACKER_ID_POS + ATTACKER_ID_SIZE]

    # Original file size
    file_size -= metadata_size + padding_size

    print('attacker id:', binascii.hexlify(attacker_id).decode().upper())
    print('metadata size: %d' % metadata_size)
    print('original file size: %d' % file_size)

    return True


#
# Main
#
if len(sys.argv) != 2:
    print('Usage:', os.path.basename(sys.argv[0]), 'filename')
    sys.exit(0)

filename = sys.argv[1]

# Get encrypted file info
if not print_encfile_info(filename):
    print('Error: file not encrypted or damaged')
    sys.exit(1)

import struct


MASK32 = 0xFFFFFFFF

add32 = lambda x, y: (x + y) & MASK32

xor32 = lambda x, y: (x ^ y) & MASK32

rol32 = lambda v, s: ((v << s) & MASK32) | ((v & MASK32) >> (32 - s))


class ChaCha(object):

    """Pure python implementation of ChaCha cipher"""

    #constants = [0x61707865, 0x3320646E, 0x79622D32, 0x6B206574]
    # "hardcore blowjob"
    constants = [0x64726168, 0x65726F63, 0x6F6C6220, 0x626F6A77]


    @staticmethod
    def quarter_round(x, a, b, c, d):
        """Perform a ChaCha quarter round"""

        x[a] = add32(x[a], x[b])
        x[d] = rol32(xor32(x[d], x[a]), 16)

        x[c] = add32(x[c], x[d])
        x[b] = rol32(xor32(x[b], x[c]), 12)

        x[a] = add32(x[a], x[b])
        x[d] = rol32(xor32(x[d], x[a]), 8)

        x[c] = add32(x[c], x[d])
        x[b] = rol32(xor32(x[b], x[c]), 7)


    @staticmethod
    def double_round(x):
        """Perform two rounds of ChaCha cipher"""

        ChaCha.quarter_round(x, 0, 4, 8, 12)
        ChaCha.quarter_round(x, 1, 5, 9, 13)
        ChaCha.quarter_round(x, 2, 6, 10, 14)
        ChaCha.quarter_round(x, 3, 7, 11, 15)
        ChaCha.quarter_round(x, 0, 5, 10, 15)
        ChaCha.quarter_round(x, 1, 6, 11, 12)
        ChaCha.quarter_round(x, 2, 7, 8, 13)
        ChaCha.quarter_round(x, 3, 4, 9, 14)


    @staticmethod
    def chacha_core(state, rounds):
        """Generate a state of a single block"""

        working_state = state[:]

        for _ in range(0, rounds // 2):
            # Perform two rounds of ChaCha cipher
            ChaCha.double_round(working_state)

        for i in range(len(working_state)):
            working_state[i] = add32(state[i], working_state[i])

        return ChaCha.words_to_bytes(working_state)


    @staticmethod
    def words_to_bytes(state):
        """Convert state to little endian bytestream"""

        return struct.pack('<16L', *state)


    @staticmethod
    def _bytes_to_words(data):
        """Convert a bytearray to array of word sized ints"""

        return list(struct.unpack('<' + str(len(data) // 4) + 'L', data))


    def __init__(self, key, nonce=12*b'\0', counter=0, rounds=20):
        """Set the initial state for the ChaCha cipher"""

        if len(key) != 32:
            raise ValueError('Key must be 32 bytes long')

        if len(nonce) == 8:
            nonce = b'\0\0\0\0' + nonce
        elif len(nonce) != 12:
            raise ValueError('Nonce must be 8 or 12 bytes long')

        self.rounds = rounds
        self.pos = 0

        # Convert bytearray key and nonce to little endian 32 bit unsigned ints
        key = ChaCha._bytes_to_words(key)
        nonce = ChaCha._bytes_to_words(nonce)
        self.state = ChaCha.constants + key + [counter] + nonce


    def _encrypt_block(self, block, block_ofs=0):
        """Encrypt a single block"""

        # Receive the key stream for current block
        key_stream = ChaCha.chacha_core(self.state, self.rounds)

        block = bytearray(block)
        for i in range(len(block)):
            block[i] ^= key_stream[i + block_ofs]

        self.pos += len(block)

        if self.pos & 0x3F == 0:
            # Increase block counter
            self.state[12] = add32(self.state[12], 1)

        return bytes(block)


    def encrypt(self, plaintext):
        """Encrypt the data"""

        encrypted_message = b''

        pos = 0

        if self.pos & 0x3F != 0:
            # Encrypt the first unaligned block
            block_ofs = self.pos & 0x3F
            block_len = min(64 - block_ofs, len(plaintext))
            encrypted_message += self._encrypt_block(plaintext[:block_len],
                                                     block_ofs)
            pos = block_len

        # Encrypt blocks
        for block in (plaintext[i : i + 64] for i
                      in range(pos, len(plaintext), 64)):
            encrypted_message += self._encrypt_block(block)

        return encrypted_message


    def decrypt(self, ciphertext):
        """Decrypt the data"""

        return self.encrypt(ciphertext)

import sys
import io
import os
import shutil
import struct
import hashlib
from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PrivateKey
from cryptography.hazmat.primitives.asymmetric.x25519 import X25519PublicKey
import chacha


# .BLackShadow
# .BLackSh
# .uploaded
# .Merlin
# .Cylance
# .Mikel
# .FAST
# .BTC
# .Proxima
RANSOM_EXT = '.BLackShadow'


METADATA_SIZE = 64
METADATA_KEY_POS = 16
X25519_KEY_SIZE = 32

# ChaCha20
CHACHA_NONCE_SIZE = 8
CHACHA_ROUNDS = 8


ENC_BLOCK_SIZE = 0x100000


# CRC32
CRC32_POLY = 0x4C11DB7
crc32_table = None


def create_crc32_table(poly: int) -> list:
    """Get CRC32 table"""

    table = list(range(256))

    for i in range(256):
        x = (i << 24) & 0xFFFFFFFF
        for j in range(8):
            if x & 0x80000000:
                x = (x << 1) ^ poly
            else:
                x <<= 1
        table[i] = x & 0xFFFFFFFF

    return table


def crc32(data: bytes, crc: int = 0xFFFFFFFF) -> int:
    """Get CRC32"""

    global crc32_table
    if crc32_table is None:
        crc32_table = create_crc32_table(CRC32_POLY)

    for b in data:
        crc = crc32_table[((crc >> 24) & 0xFF) ^ b] ^ ((crc & 0xFFFFFF) << 8)
    return crc


def decrypt_file(filename: str, priv_key: bytes) -> bool:
    """Decrypt file"""

    with io.open(filename, 'rb+') as f:

        # Read metadata
        try:
            f.seek(-METADATA_SIZE, 2)
        except OSError:
            return False

        metadata = f.read(METADATA_SIZE)

        pos = METADATA_KEY_POS

        # Derive Curve25519-donna shared key
        pub_key = metadata[pos : pos + X25519_KEY_SIZE]
        private_key = X25519PrivateKey.from_private_bytes(priv_key)
        public_key = X25519PublicKey.from_public_bytes(pub_key)
        shared_secret = private_key.exchange(public_key)

        # Get ChaCha20 encryption key
        h = hashlib.sha256()
        h.update(shared_secret)
        key = h.digest()

        pos += X25519_KEY_SIZE
        nonce = metadata[pos : pos + CHACHA_NONCE_SIZE]

        # Check encryption key CRC32
        pos += CHACHA_NONCE_SIZE
        key_crc, = struct.unpack_from('<L', metadata, pos)
        if key_crc != crc32(key):
            return False

        cipher = chacha.ChaCha(key, nonce, 0, CHACHA_ROUNDS)

        # Decrypt chunk info
        enc_chunk_info = metadata[:METADATA_KEY_POS]
        chunk_info = cipher.decrypt(enc_chunk_info)

        num_chunks, chunk_space = struct.unpack('<QQ', chunk_info)

        # Remove metadata
        f.seek(-METADATA_SIZE, 2)
        f.truncate()

        # Decrypt file data
        pos = 0

        for _ in range(num_chunks):

            # Decrypt block
            f.seek(pos)
            enc_data = f.read(ENC_BLOCK_SIZE)
            if enc_data == b'':
                break

            dec_data = cipher.decrypt(enc_data)

            f.seek(pos)
            f.write(dec_data)

            pos += ENC_BLOCK_SIZE + chunk_space

    return True


#
# Main
#
if len(sys.argv) != 2:
    print('Usage:', os.path.basename(sys.argv[0]), 'filename')
    sys.exit(0)

filename = sys.argv[1]

with io.open('privkey.bin', 'rb') as f:
    priv_key = f.read(X25519_KEY_SIZE)

# "hardcore blowjob"
chacha.ChaCha.constants = [0x64726168, 0x65726F63, 0x6F6C6220, 0x626F6A77]

# Copy file
new_filename = filename
if new_filename.endswith(RANSOM_EXT):
    new_filename = new_filename[:-len(RANSOM_EXT)]
else:
    new_filename += '.dec'
shutil.copy(filename, new_filename)

# Decrypt file
if not decrypt_file(new_filename, priv_key):
    print('Error: Failed to decrypt file')
    sys.exit(1)

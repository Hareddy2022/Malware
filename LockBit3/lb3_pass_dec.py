import binascii
import struct


PASSWORD_LEN = 16
DERIVE_KEY_ITERATIONS = 6


MASK32 = 0xFFFFFFFF

rol32 = lambda v, s: ((v << s) & MASK32) | ((v & MASK32) >> (32 - s))

ror32 = lambda v, s: ((v & MASK32) >> s) | ((v << (32 - s)) & MASK32)

bswap32 = lambda v: \
    ((v & 0xFF) << 24) | ((v & 0xFF00) << 8) | \
    ((v & 0xFF0000) >> 8) | ((v >> 24) & 0xFF)


def derive_key(pwd):
    """Derive key from password"""
    data = b''

    x = list(struct.unpack('<4L', pwd))

    for _ in range(DERIVE_KEY_ITERATIONS):
        x[0] = (ror32(bswap32(x[0]), 13) ^ MASK32) ^ bswap32(rol32(x[1], 11))
        x[1] = bswap32(rol32(x[2], 9))
        x[2] = (x[1] ^ MASK32) ^ bswap32(rol32(x[3], 7))
        x[3] = (x[2] ^ MASK32) ^ rol32(x[2], 5)
        data += struct.pack('<4L', *x)

    return data


def vmpc_ksa3(key):
    """VMPC KSA"""
    p = list(range(256))

    key0 = key[32:]
    key1 = key[:32]

    s = 0

    for _ in range(3):
        for i in range(256):
            s = p[(s + p[i] + key0[i % len(key0)]) & 0xFF]
            p[i], p[s] = p[s], p[i]

    for _ in range(3):
        for i in range(256):
            s = p[(s + p[i] + key1[i % len(key1)]) & 0xFF]
            p[i], p[s] = p[s], p[i]

    for _ in range(3):
        for i in range(256):
            s = p[(s + p[i] + key0[i % len(key0)]) & 0xFF]
            p[i], p[s] = p[s], p[i]

    return p, s


def vmpc_prga(p, s):
    """VMPC PRGA"""
    i = 0
    while True:
        s = p[(s + p[i]) & 0xFF]
        x = p[(p[p[s]] + 1) & 0xFF]
        p[i], p[s] = p[s], p[i]
        i = (i + 1) & 0xFF
        yield x


if __name__ == '__main__':
    import sys
    import io
    import os

    if len(sys.argv) < 3:
        print('Usage:', os.path.basename(sys.argv[0]), 'pass datafile [skip_bytes ...]')
        sys.exit(0)

    skip_blocks = [int(sys.argv[i], 16) for i in range(3, len(sys.argv))]

    pwd = binascii.unhexlify(sys.argv[1])
    filename = sys.argv[2]

    with io.open(filename, 'rb') as f:
        data = bytearray(f.read())

    key = derive_key(pwd)
    p, s = vmpc_ksa3(key)

    for skip_bytes in skip_blocks:
        keystream = vmpc_prga(p, s)
        for _ in range(skip_bytes):
            next(keystream)

    keystream = vmpc_prga(p, s)

    for i in range(len(data)):
        data[i] ^= next(keystream)

    new_filename = filename + '.dec'
    with io.open(new_filename, 'wb') as f:
        f.write(data)

    print('Done!')

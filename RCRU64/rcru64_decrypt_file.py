import sys
import io
import os
import shutil
import base64
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Hash import SHA1
from Crypto.Cipher import AES


RANSOM_EXT_PREFIX = '_[ID-'


# Markers
METADATA_MARKER = b'wenf='
METADATA_MARKER2 = b'&4r*3d'

CHUNK_INFO_MARKER1 = b'P7A1s'
CHUNK_INFO_MARKER2 = b':'
CHUNK_INFO_MARKER3 = b'$f1;'

ENC_SIZE_MARKER = b'Fs1z3'

KEYDATA_MARKER1 = b'd7j3'
KEYDATA_MARKER2 = b'y9a0'
KEYDATA_MARKER3 = b'm5ha'

SMALL_FILE_END_MARKERS = [
    b'nqpso5938fh71jfu',
    b'qpso5938fh71jf'
]


# RSA
RSA_KEY_SIZE = 256

# AES GCM
NONCE_SIZE1 = 12
NONCE_SIZE2 = 32
MAC_TAG_SIZE = 16


# Metadata
MAX_METADATA_SIZE = 0x12C
MIN_METADATA_SIZE = RSA_KEY_SIZE + len(METADATA_MARKER)
ADDITION_DATA_SIZE = 1


MIN_BIG_FILE_SIZE = 0x1F4000
BIG_FILE_CHUNK_SIZE = 0x2D2A8
SMALL_FILE_CHUNK_SIZE = 0x7D000

BLOCK_SIZE = 1024000


def rsa_decrypt(enc_data: bytes, priv_key_data: bytes) -> bytes:
    """RSA OAEP decrypt data"""

    key = RSA.import_key(priv_key_data)
    decryptor = PKCS1_OAEP.new(key, hashAlgo=SHA1)

    try:
        return decryptor.decrypt(enc_data)
    except ValueError:
        return None


def decrypt_file(filename: str, priv_key_data: bytes) -> bool:
    """Decrypt file
    TODO: Implementation of the nonce for the 2nd and following chunks
    """

    with io.open(filename, 'rb+') as f:

        # Get file size
        f.seek(0, 2)
        file_size = f.tell()
        if file_size < len(METADATA_MARKER2):
            return False

        # Check and remove end marker
        f.seek(-len(METADATA_MARKER2), 2)
        marker = f.read(len(METADATA_MARKER2))
        if marker == METADATA_MARKER2:
            file_size -= len(METADATA_MARKER2)
            f.truncate(file_size)

        if file_size < MIN_METADATA_SIZE:
            return False

        # Read metadata
        size = min(file_size, MAX_METADATA_SIZE)
        f.seek(-size, 2)
        metadata = f.read(size)

        pos = metadata.find(METADATA_MARKER)
        if pos < 0:
            return False

        file_size -= size - pos

        pos += len(METADATA_MARKER)
        metadata = metadata[pos:]

        pos = metadata.find(CHUNK_INFO_MARKER1)
        if pos >= 0:

            # Get encrypted key data
            enc_keydata = metadata[:pos]

            # Spot encryption

            # Chunk size
            pos += len(CHUNK_INFO_MARKER1)
            pos2 = metadata.find(CHUNK_INFO_MARKER2, pos)
            if pos2 < 0:
                return False

            chunk_size = int(float(metadata[pos : pos2]) * BLOCK_SIZE)

            # Chunk space
            pos = pos2 + len(CHUNK_INFO_MARKER2)
            pos2 = metadata.find(CHUNK_INFO_MARKER3, pos)
            if pos2 < 0:
                return False

            chunk_space = int(float(metadata[pos : pos2]) * BLOCK_SIZE)

            # Encryption size
            pos = pos2 + len(CHUNK_INFO_MARKER3)
            pos = metadata.find(ENC_SIZE_MARKER, pos)
            if pos < 0:
                return False

            pos += len(ENC_SIZE_MARKER)
            enc_size = int(metadata[pos:])

            nonce_size = NONCE_SIZE1

        else:
            # Get encrypted key data
            enc_keydata = metadata

            # Full encryption
            chunk_space = 0
            enc_size = file_size

            if file_size >= MIN_BIG_FILE_SIZE:
                chunk_size = BIG_FILE_CHUNK_SIZE
                nonce_size = NONCE_SIZE2
            elif file_size <= SMALL_FILE_CHUNK_SIZE:
                chunk_size = file_size
                enc_size -= MAC_TAG_SIZE
                nonce_size = NONCE_SIZE2
            else:
                chunk_size = SMALL_FILE_CHUNK_SIZE
                nonce_size = NONCE_SIZE1

        # Decrypt key data
        keydata = rsa_decrypt(enc_keydata, priv_key_data)
        if keydata is None:
            return False

        # Parse key data
        pos = keydata.find(KEYDATA_MARKER1)
        if pos < 0:
            return False

        pos += len(KEYDATA_MARKER1)
        pos2 = keydata.find(KEYDATA_MARKER2, pos)
        if pos2 < 0:
            return False

        # Get encryption key
        key = keydata[pos : pos2]

        pos = pos2 + len(KEYDATA_MARKER2)
        pos2 = keydata.find(KEYDATA_MARKER3, pos)
        if pos2 < 0:
            return False

        # Get nonce
        nonces = keydata[pos : pos2]

        nonce = nonces[:nonce_size]

        # Decrypt file data
        pos = 0

        while pos < enc_size:

            f.seek(pos)
            size = min(enc_size - pos, chunk_size)
            enc_data = f.read(size)
            if enc_data == b'':
                break

            # Decrypt chunk
            cipher = AES.new(key, AES.MODE_GCM, nonce)
            data = cipher.decrypt(enc_data)

            f.seek(pos)
            f.write(data)

            pos += chunk_size + chunk_space

        if chunk_size == file_size:
            # Remove end marker in small file
            size = len(max(SMALL_FILE_END_MARKERS, key=len))
            f.seek(file_size - size)
            data = f.read(size)
            for marker in SMALL_FILE_END_MARKERS:
                pos = data.find(marker)
                if pos >= 0:
                    file_size -= size - pos
                    break

        file_size -= ADDITION_DATA_SIZE

        # Remove additional data
        f.truncate(file_size)

    with io.open('keydata.bin', 'wb') as f:
        f.write(keydata)

    return True


#
# Main
#
if len(sys.argv) != 2:
    print('Usage:', os.path.basename(sys.argv[0]), 'filename')
    sys.exit(0)

filename = sys.argv[1]

with io.open('rsa_privkey.txt', 'rb') as f:
    priv_key_data = base64.b64decode(f.read())

# Copy file
pos = filename.find(RANSOM_EXT_PREFIX)
if pos >= 0:
    new_filename = filename[:pos]
else:
    new_filename = filename + '.dec'
shutil.copy(filename, new_filename)

# Decrypt file
if not decrypt_file(new_filename, priv_key_data):
    print('Error: Failed to decrypt file')
    sys.exit(1)
